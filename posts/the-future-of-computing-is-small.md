---
title: 'The Future of Computing is Small'
date: '2022-03-01T17:00:00'
---

As the scarcity of our natural resources (including human capacity) become ever more apparent, there is an accelerating need to reduce the consumption of these resources.  In addition to simply reducing consumption, we can also improve and expand the use of tools that produce what we want and need from resources which have no natural scarcity. Small computing is an approach to computing that can do both, while at the same time making the power of computing accessible to more people.
Not specifically physically small (although I suppose that two), but smaller in complexity, smaller in overhead, smaller negative side-effects.

I've written about [some of these ideas before](https://www.jasongullickson.com/posts/human-scale-software), but it's something I want to elaborate on because I've been exploring the application of these ideas beyond software development alone.

The computers we depend on have grown exponentially more complex than the ones we created at the dawn of the personal computer revolution.  I think this is an important point of demarcation because computers existed for a long time before this revolution, but it was the personal computer revolution that put the power of programming within reach of people outside of military, industrial or academic control.  Before this point computing power was tightly guarded and metered-out based on the organization's perception of the validity of the programmer's ideas, and often this value was measured in terms unrelated to the programmers (or humanity's) interests.

This break resulted in an explosion of creativity and as a result entire new fields and industries were created.  For a brief time it looked like personal computers would liberate people from drudgery and allow for anyone with an idea or a need to enjoy the scarcity-destroying magic of creating and distributing things through writing software.

Fifty years later (has it been *that* long?), this power has been reigned back in by the same forces that kept it out of most people's hands in the first place, and in a lot of ways "the cloud" has turned all our personal computers into little more than terminals connected to a handful of mainframes owned by a handful of companies.

This is big computing, and it is the opposite of small computing.

Small computing isn't simply a throwback or nostalgia for the personal computers of old.  True, it is about looking at what we had, and remembering what was possible while at the same time cherry-picking the best of what we have now and finding ways to keep those "good parts" while eschewing the things that have led us off the path of using computers to make life better.

> An extreme example of small computing is [CollapseOS](http://collapseos.org/).  Intended to preserve the utility of programmable computers after the end of civilization, CoS shows it's possible to create useful, self-hosted personal computers using simple, robust, low-power components.  A CoS system has all the tools you need to write programs and even extend the operating system itself, and interface this software with a wide-range of hardware to recreate existing and invent new ways to use computers.

But small computing isn't only useful at the end of the world.  Big computing has enormous costs in terms of freedom, privacy, flexibility and impact on the natural world.  On top of this, the intellectual cost involved in writing software for big computers is staggering.  Most professional programmers work in environments where it would be virtually impossible for them to write software without the help of other big computer resources.  Search engines, knowledge sharing websites and now even artificial intelligence is needed simply to document the complexity of big computing programming languages, toolkits, platforms and API's.  Where once it was possible for a programmer to commit an entire programming language to memory, it is now impossible to write "production" software without the help of other sofware stacked on top of other software stacked on top of...

This would be more acceptable if there were no other way to make computers useful, but that's not the case.  Part of my work on small computing is studying how people use computers and running experiments to see how these same things can be accomplished without the costs of big computing.  Through this research I am defining categories of use and I've found that part of the reason computers have become so big is that they have absorbed roles that have little to do with computing historically.  In many cases these applications are not a good fit for digital computers but were forced into this environment for reasons that have little to do with good engineering.  

> As is often the case, the personal computer has been used to build all sorts of things that would be much smaller, much more efficient and simply more logical to be implemented in other ways, but due to market forces and other non-technical parameters it happened anyway.

As I continue this work I will try to share practical examples of replacing big computing with small, and work with others who are interested to achieve these goals.  It takes some discipline to see how we might preserve what we enjoy and value about our big computers using small ones, but I've found the work to be quite pleasurable and the intellectual challenge to be much more invigorating than continuing to force big computing's limitless appetite for resources into the physical limits of our world.